"use strict";
exports.__esModule = true;
exports.RING_SHADER_FRAGMENT = exports.RING_SHADER_VERTEX = exports.SPHERE_SHADER_FRAGMENT = exports.SPHERE_SHADER_VERTEX = exports.ATMOSPHERE_SHADER_FRAGMENT = exports.ATMOSPHERE_SHADER_VERTEX = exports.GENERIC_PARTICLE_SHADER_FRAGMENT = exports.GENERIC_PARTICLE_SHADER_VERTEX = exports.STAR_SHADER_VERTEX = exports.STAR_SHADER_FRAGMENT = exports.getOrbitShaderVertex = exports.getOrbitShaderFragment = void 0;
var Scale_1 = require("./Scale");
/**
 * @ignore
 */
function getOrbitShaderFragment() {
    return "\n    varying vec3 vColor;\n    uniform sampler2D texture;\n\n    void main() {\n      gl_FragColor = vec4(vColor, 1.0) * texture2D(texture, gl_PointCoord);\n    }\n  ";
}
exports.getOrbitShaderFragment = getOrbitShaderFragment;
/**
 * @ignore
 */
function getOrbitShaderVertex() {
    return "\n    attribute vec3 fuzzColor;\n    attribute vec3 origin;\n    varying vec3 vColor;\n\n    attribute float size;\n\n    attribute float a;\n    attribute float e;\n    attribute float i;\n    attribute float om;\n    attribute float wBar;\n    attribute float M;\n\n    // Perihelion distance\n    attribute float q;\n\n    // CPU-computed term for parabolic orbits\n    attribute float a0;\n\n    // COSH Function (Hyperbolic Cosine)\n    float cosh(float val) {\n      float tmp = exp(val);\n      float cosH = (tmp + 1.0 / tmp) / 2.0;\n      return cosH;\n    }\n\n    // TANH Function (Hyperbolic Tangent)\n    float tanh(float val) {\n      float tmp = exp(val);\n      float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n      return tanH;\n    }\n\n    // SINH Function (Hyperbolic Sine)\n    float sinh(float val) {\n      float tmp = exp(val);\n      float sinH = (tmp - 1.0 / tmp) / 2.0;\n      return sinH;\n    }\n\n    // Cube root helper that assumes param is positive\n    float cbrt(float x) {\n      return exp(log(x) / 3.0);\n    }\n\n    vec3 getPosNearParabolic() {\n      // See https://stjarnhimlen.se/comp/ppcomp.html#17\n      float b = sqrt(1.0 + a0 * a0);\n      float W = cbrt(b + a0) - cbrt(b - a0);\n      float f = (1.0 - e) / (1.0 + e);\n\n      float a1 = 2.0 / 3.0 + (2.0 / 5.0) * W * W;\n      float a2 = 7.0 / 5.0 + (33.0 / 35.0) * W * W + (37.0 / 175.0) * pow(W, 4.0);\n      float a3 =\n        W * W * (432.0 / 175.0 + (956.0 / 1125.0) * W * W + (84.0 / 1575.0) * pow(W, 4.0));\n\n      float C = (W * W) / (1.0 + W * W);\n      float g = f * C * C;\n      float w = W * (1.0 + f * C * (a1 + a2 * g + a3 * g * g));\n\n      // True anomaly\n      float v = 2.0 * atan(w);\n      // Heliocentric distance\n      float r = (q * (1.0 + w * w)) / (1.0 + w * w * f);\n\n      // Compute heliocentric coords.\n      float i_rad = i;\n      float o_rad = om;\n      float p_rad = wBar;\n      float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));\n      return vec3(X, Y, Z);\n    }\n\n    vec3 getPosHyperbolic() {\n      float F0 = M;\n      for (int count = 0; count < 100; count++) {\n        float F1 = (M + e * (F0 * cosh(F0) - sinh(F0))) / (e * cosh(F0) - 1.0);\n        float lastdiff = abs(F1 - F0);\n        F0 = F1;\n\n        if (lastdiff < 0.0000001) {\n          break;\n        }\n      }\n      float F = F0;\n\n      float v = 2.0 * atan(sqrt((e + 1.0) / (e - 1.0))) * tanh(F / 2.0);\n      float r = ".concat((0, Scale_1.getScaleFactor)().toFixed(1), " * (a * (1.0 - e * e)) / (1.0 + e * cos(v));\n\n      // Compute heliocentric coords.\n      float i_rad = i;\n      float o_rad = om;\n      float p_rad = wBar;\n      float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));\n      return vec3(X, Y, Z);\n    }\n\n    vec3 getPosEllipsoid() {\n      float i_rad = i;\n      float o_rad = om;\n      float p_rad = wBar;\n\n      // Estimate eccentric and true anom using iterative approximation (this\n      // is normally an intergral).\n      float E0 = M;\n      float E1 = M + e * sin(E0);\n      float lastdiff = abs(E1-E0);\n      E0 = E1;\n\n      for (int count = 0; count < 100; count++) {\n        E1 = M + e * sin(E0);\n        lastdiff = abs(E1-E0);\n        E0 = E1;\n        if (lastdiff < 0.0000001) {\n          break;\n        }\n      }\n\n      float E = E0;\n      float v = 2.0 * atan(sqrt((1.0+e)/(1.0-e)) * tan(E/2.0));\n\n      // Compute radius vector.\n      float r = ").concat((0, Scale_1.getScaleFactor)().toFixed(1), " * a * (1.0 - e * e) / (1.0 + e * cos(v));\n\n      // Compute heliocentric coords.\n      float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));\n      float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));\n      return vec3(X, Y, Z);\n    }\n\n    vec3 getPos() {\n      if (e > 0.9 && e < 1.2) {\n        return getPosNearParabolic();\n      } else if (e > 1.2) {\n        return getPosHyperbolic();\n      }\n      return getPosEllipsoid();\n    }\n\n    void main() {\n      vColor = fuzzColor;\n\n      vec3 newpos = getPos() + origin;\n      vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.0);\n      gl_Position = projectionMatrix * mvPosition;\n      gl_PointSize = size;\n    }\n  ");
}
exports.getOrbitShaderVertex = getOrbitShaderVertex;
exports.STAR_SHADER_FRAGMENT = "\n    varying vec3 vColor;\n\n    void main() {\n      float a = 1.0 - 2.0 * length(gl_PointCoord - vec2(0.5, 0.5));\n      gl_FragColor = vec4(vColor, a);\n    }\n";
exports.STAR_SHADER_VERTEX = "\n    attribute float size;\n    varying vec3 vColor;\n\n    void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_PointSize = size;\n        gl_Position = projectionMatrix * mvPosition;\n    }\n";
exports.GENERIC_PARTICLE_SHADER_VERTEX = "\n    attribute float size;\n    attribute vec3 customColor;\n    varying vec3 vColor;\n    void main() {\n      vColor = customColor;\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n      gl_PointSize = size * (300.0 / -mvPosition.z);\n      gl_Position = projectionMatrix * mvPosition;\n    }\n";
exports.GENERIC_PARTICLE_SHADER_FRAGMENT = "\n    uniform vec3 color;\n    uniform sampler2D texture;\n    varying vec3 vColor;\n    void main() {\n      gl_FragColor = vec4(color * vColor, 1.0);\n      gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n      if (gl_FragColor.a < ALPHATEST) discard;\n    }\n";
exports.ATMOSPHERE_SHADER_VERTEX = "\n  uniform vec3 lightPos;\n\n  varying vec2 vUv;\n  varying vec3 vecPos;\n  varying vec3 vecNormal;\n  //varying vec3 vNormal;\n\n  varying vec3 vViewLightPos;\n\n  void main() {\n    //vNormal = normalize(normalMatrix * normal);\n    //gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    vUv = uv;\n    // Since the light is in camera coordinates,\n    // I'll need the vertex position in camera coords too\n    vecPos = (modelViewMatrix * vec4(position, 1.0)).xyz;\n    // That's NOT exacly how you should transform your\n    // normals but this will work fine, since my model\n    // matrix is pretty basic\n    vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\n    vViewLightPos = (viewMatrix * vec4(lightPos, 1.0)).xyz;\n    gl_Position = projectionMatrix * vec4(vecPos, 1.0);\n  }\n";
// With help from https://stackoverflow.com/questions/43621274/how-to-correctly-set-lighting-for-custom-shader-material
exports.ATMOSPHERE_SHADER_FRAGMENT = "\n  uniform float c;\n  uniform float p;\n  uniform vec3 color;\n\n  varying vec2 vUv;\n  varying vec3 vecPos;\n  varying vec3 vecNormal;\n  varying vec3  vViewLightPos;\n\n  void main() {\n    float intensity = pow(c - dot(vecNormal, vec3(0.0, 0.0, 1.0)), p);\n\n    vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 lightDirection = normalize(vecPos - vViewLightPos);\n    addedLights.rgb += clamp(dot(-lightDirection, vecNormal), 0.0, 1.0)\n                       * 1.0 /* intensity */;\n                       // * pointLights[i].color\n\n    gl_FragColor = vec4(color, 1.0) * intensity * addedLights;\n  }\n";
exports.SPHERE_SHADER_VERTEX = "\n  uniform vec3 lightPos;\n\n  varying vec2 vUv;\n  varying vec3 vViewPosition;\n  varying vec3 vViewLightPos;\n  varying vec3 vNormal;\n\n  void main() {\n    vUv = uv;\n    vec4 vViewPosition4 = modelViewMatrix * vec4(position, 1.0);\n    vViewPosition = vViewPosition4.xyz;\n    vViewLightPos = (viewMatrix * vec4(lightPos, 1.0)).xyz;\n    vNormal = normalMatrix * normal;\n\n    gl_Position = projectionMatrix * vViewPosition4;\n  }\n";
exports.SPHERE_SHADER_FRAGMENT = "\n  uniform sampler2D sphereTexture;\n\n  varying vec2 vUv;\n  varying vec3 vNormal;\n  varying vec3 vViewPosition;\n  varying vec3 vViewLightPos;\n\n  void main() {\n    vec3 normal = normalize(vNormal);\n    vec3 lightDir = normalize(vViewLightPos - vViewPosition);\n    float lambertian = max(dot(normal, lightDir), 0.0);\n    gl_FragColor = texture2D(sphereTexture, vUv) * vec4(vec3(1.0) * lambertian, 1.0);\n  }\n";
exports.RING_SHADER_VERTEX = "\n  varying vec3 vPos;\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n\n  void main() {\n    vPos = position;\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.));\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition.xyz, 1.);\n\n    vNormal = normalMatrix * normal;\n    vWorldPosition = worldPosition.xyz;\n  }\n";
exports.RING_SHADER_FRAGMENT = "\n  uniform sampler2D ringTexture;\n  uniform float innerRadius;\n  uniform float outerRadius;\n  uniform vec3 lightPos;\n\n  varying vec3 vNormal;\n  varying vec3 vPos;\n  varying vec3 vWorldPosition;\n\n  vec4 color() {\n    vec2 uv = vec2(0);\n    uv.x = (length(vPos) - innerRadius) / (outerRadius - innerRadius);\n    if (uv.x < 0.0 || uv.x > 1.0) {\n      discard;\n    }\n\n    vec4 pixel = texture2D(ringTexture, uv);\n    return pixel;\n  }\n\n  vec3 shadow() {\n    vec3 lightDir = normalize(vPos - lightPos);\n    vec3 planetPos = vec3(0);\n\n    vec3 ringPos = vPos - planetPos;\n    float posDotLightDir = dot(ringPos, lightDir);\n    float posDotLightDir2 = posDotLightDir * posDotLightDir;\n\n    // TODO(ian): Generalize this line.\n    float radius = 0.0389259903; // radius of saturn in coordinate system\n    float radius2 = radius * radius;\n\n    if (posDotLightDir > 0.0 && dot(ringPos, ringPos) - posDotLightDir2 < radius2) {\n      return vec3(0.0);\n    }\n    return vec3(1.0);\n  }\n\n  vec3 lights() {\n    vec3 lightDirection = normalize(vWorldPosition - lightPos);\n    float c = 0.35 + max(0.0, dot(vNormal, lightDirection)) * 0.4;\n\n    return vec3(c);\n  }\n\n  void main() {\n    // NOTE: The order of multiplication matters here. color() may call\n    // discard, which would cause problems on some Windows graphics drivers if\n    // it is a left operand.\n    // https://github.com/typpo/spacekit/issues/22\n    gl_FragColor = vec4(lights() * shadow(), 1.0) * color();\n  }\n";
